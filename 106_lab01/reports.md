### 实验一——调试分析 Linux 0.00 引导程序

#### 1.请简述 `head.s` 的工作原理

`head.s`文件是Linux 0.00内核引导过程中至关重要的一部分，它负责设置系统的初始状态并加载内核程序到内存中，以便Linux操作系统能够成功启动和运行。head.s文件的工作原理如下：

1. 首先，`head.s`文件将设置段寄存器和栈指针，以确保程序可以正确地执行和访问内存。
2. 接下来，`head.s`文件将读取内核映像文件的头部信息，以获取内核程序的大小和入口点等信息。
3. 接着，`head.s`文件将将内核程序从磁盘中加载到内存中，将其复制到正确的内存位置。
4. 然后，`head.s`文件将设置正确的系统调用向量表，以便内核程序可以正确地响应系统调用。
5. 最后，`head.s`文件将跳转到内核程序的入口点，将控制权转交给内核程序，并开始运行Linux操作系统。

#### 2.请记录 `head.s` 的内存分布状况，写明每个数据段，代码段，栈段的起始与终止的内存地址

`head.s`涉及到这么几个内存段：

+ 内核代码段，0x000000~0X7FFFFF，大小8MB，对应GDT选择子0x08.
+ 内核数据段，0x000000~0X7FFFFF，大小8MB，对应GDT选择子0x10。这个段同时也被栈所使用，初始栈顶位于 init_stack 处，栈空间512字节。另外，在中断时进入到内核态时，此时的内核栈对应 krn_stK1 处的512字节。
+ 显存段，0xB8000~0xB9FFF，大小8KB，对应GDT选择子0x18。
+ task0代码段，0xD00000~0X7FFFFF，大小8MB，对应LDT0选择子0x0F。
+ task0数据段，0x000000~0X7FFFFF，大小8MB，对应LDT0选择子0x17。这个段同时也被栈所使用，初始栈顶位于 init_stack 处，栈空间512字节
+ task1代码段，0x000000~0X7FFFFF，大小8MB，对应LDT1选择子0x0F。
+ task1数据段，0x000000~0X7FFFFF，大小8MB，对应LDT0选择子0x17。这个段同时也被栈所使用，初始栈顶位于 usr_stk1 处，栈空间512字节。

#### 3.简述 `head.s` `57` 至 `62` 行在做什么？

是在初始堆栈中人工设置返回环境。

+ 57：把任务0当前局部空间数据段（堆栈段）选择符入栈
+ 58：把堆栈指针入栈（也可以把ESP入栈）
+ 59：把标志寄存器入栈
+ 60：把当前局部空间代码段选择符入栈
+ 61：把代码指针入栈
+ 62：执行中断返回指令，从而切换到特权级了的任务0中执行

#### 4.简述 `iret` 执行后， `pc` 如何找到下一条指令？

`iret`指令用于从中断处理程序中返回到被中断的程序，并恢复被中断程序的现场。执行`iret`指令后，处理器会执行以下操作：

1. 弹出SS和ESP寄存器中的值，以恢复被中断程序的堆栈指针。
2. 从堆栈中弹出EFLAGS寄存器的值，以恢复被中断程序的标志位。
3. 从堆栈中弹出CS和EIP寄存器的值，以恢复被中断程序的代码指针。

因此，`iret`指令执行后，程序计数器PC将指向被中断程序被中断前执行的下一条指令。具体来说，`iret`指令会将从堆栈中弹出的CS和EIP寄存器的值组合成一个32位的线性地址，然后将该线性地址存储在程序计数器PC中，以便继续执行被中断程序被中断前的指令。

#### 5.记录 `iret` 执行前后，栈是如何变化的？

打开Bochs，在文本框输入调试命令vb 0x08:0，在内核程序的入口处插个断点，处理器就执行到内核程序入口前。在反汇编窗口区里找到跳转到task0的`iret`指令，在这条指令处插个断点。

执行`iret`前，栈顶SS:ESP 指向0x10:0x0BC4，栈中看到之前往栈顶里压入的跳转目标地址0x0F:0x10E0 和用户栈栈顶地址0x17:0x0BD8。

![屏幕截图 2023-05-13 161607](.\img\屏幕截图 2023-05-13 161607.jpg)

点Step[s]，仅执行`iret`指令，栈顶SS:ESP自动切换到之前指定的用户栈栈顶0x17:0x0BD8，而且现在CS:EIP 跳转到了0x0F:0x10E0 执行。

![image-20230513162230285](.\img\image-20230513162230285.png)

#### 6.当任务进行系统调用时，即 `int 0x80` 时，记录栈的变化情况。

处理器执行到`int 0x80`之前，现在栈顶SS:ESP指向0x17:0x0BD8，此时CS:EIP=0x0F:0x10E9

![屏幕截图 2023-05-13 162835](.\img\屏幕截图 2023-05-13 162835.jpg)

点Step[s]执行指令，观察栈的变化：

![屏幕截图 2023-05-13 163116](.\img\屏幕截图 2023-05-13 163116.jpg)

SS:ESP切换到了task0内核栈0x10:0x0E4C处，并且CS:EIP跳转到了系统调用中断处理程序入口地址0x08:0x0166处。并且原来的用户栈栈顶地址0x17:0x0BD8和中断返回地址0x0F:0x10EB被压到了内核栈栈顶。
