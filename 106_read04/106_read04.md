### Read-04

#### 任务管理

#### 1. 任务管理概述

+ 任务是可以独立执行的程序或程序的一部分。任务由执行上下文组成，包括它自己的一组寄存器和内存堆栈。
+ 80x86架构为任务切换提供硬件支持，允许处理器在不同任务之间高效切换。
+ 描述符表中与任务相关的描述符包括任务状态段(Task State Segment, TSS)描述符，它保存有关任务状态的信息，例如任务的寄存器和内存堆栈。
+ 任务切换和过程调用是将控制转移到另一部分代码的两种不同机制。任务切换涉及保存当前任务的状态并恢复另一个任务的状态，而过程调用涉及将当前执行上下文推入堆栈，然后在返回原始上下文之前执行另一部分代码。

#### 1.1. 任务的结构

**一个任务由几部分组成?**
		在x86架构中，一个任务由两部分组成:任务状态段(TSS)和任务执行空间。TSS包含有关任务状态的信息，例如任务的寄存器值及其堆栈的位置。任务执行空间包括任务的代码和数据段，以及它的堆栈段。TSS和任务执行空间作为描述符表的一部分存储在内存中。

**任务执行空间包括什么?**
		任务执行空间包括任务的代码段和数据段，以及它的堆栈段。代码段包含任务的可执行指令，而数据段包含任务的静态和全局数据。堆栈段用于在任务执行期间存储局部变量和函数参数。堆栈段的大小由TSS的SS和SP寄存器决定。

**为什么有多个特权堆栈空间?**
		x86架构支持多个特权级别，称为保护环，其范围从ring 0(特权级别最高)到ring 3(特权级别最低)。每个特权级别都有自己的一组寄存器和内存段，包括自己的堆栈空间。当任务从高特权级别切换到低特权级别时，处理器将高特权级别的状态保存在相应的特权堆栈空间中。这确保任务以适当的特权级别执行，并防止对系统资源的未经授权的访问。使用多个特权堆栈空间来确保每个特权级别都有自己独立的堆栈空间，从而防止损坏或对堆栈数据的未经授权的访问。

#### 1.2. 任务状态

**当前正在执行的任务的状态是什么?**
		当前正在执行的任务的状态存储在处理器的任务寄存器(TR)中。TR指向当前执行任务的TSS，并包含有关任务状态的信息，包括其寄存器、标志和内存段。

**这些的含义是什么?**
		TSS(任务状态段)包含关于任务的各种信息，包括其通用寄存器、段寄存器和其他CPU状态的状态。它还包括指向任务代码、数据段和堆栈的指针，以及指示任务当前特权级别和当前是否正在执行的标志。

**为什么要包括这些?**
		TSS包含在x86架构中，以方便任务切换和管理。通过将有关任务状态的所有必要信息存储在单独的内存段中，处理器可以有效地在不同的任务之间切换，而不会丢失重要的上下文信息。这允许多个任务在单个处理器上并发运行，从而提高系统性能和响应能力。此外，通过在TSS中存储任务的特权级别和其他与安全相关的信息，处理器可以确保每个任务都以适当的特权级别执行，并防止对系统资源的未经授权的访问。

#### 1.3. 任务的执行

**有多少种方法可以执行任务?**
		在x86架构中有两种执行任务的方法:使用任务切换或使用调用门。任务切换是一种允许处理器从执行一个任务切换到另一个任务的机制，而调用门是通过调用指定过程将控制从一个任务转移到另一个任务的方法。

**Linux 0.00的工作方式是什么?**
		Linux 0.00 使用任务切换来管理进程。它实现了一个简单的循环调度算法，允许多个进程在单个处理器上运行。

**任务可以递归调用吗?为什么?**
		在x86架构中可以递归地调用任务。这是因为每个任务都有自己的堆栈，允许它存储局部变量和函数参数。当任务调用子例程时，它将必要的信息推入自己的堆栈，当子例程返回时，它将信息弹出堆栈。这允许任务递归地调用子例程(包括它们自己)，而不会干扰其他任务或整个系统的状态。

#### 2. 任务的数据结构

**任务状态段(task - state Segment, TSS):**

​		是一种数据结构，它包含有关任务状态的信息，包括其通用寄存器、内存段和堆栈指针的状态。当任务切换发生时，处理器使用它来保存和恢复任务的状态。每个TSS与单个任务相关联，处理器为每个可以执行的任务维护一个单独的TSS。
​		TSS包含几个描述任务状态的字段，例如任务的堆栈指针、指令指针和其他寄存器值。它还包含指向任务的代码、数据和堆栈段的段选择器。TSS存储在内存中，可以使用段描述符访问。

**TSS描述符:**

​		TSS描述符是描述TSS的位置和属性的段描述符。它存储在全局描述符表(GDT)或本地描述符表(LDT)中，包括内存中TSS的基址、它的限制、访问权限和其他属性。
​		当任务切换发生时，处理器使用TSS描述符来定位任务的TSS。任务寄存器(TR)中的段选择器指向当前执行任务的TSS描述符，当任务切换发生时，处理器将新任务的TSS描述符的段选择器加载到TR中。

**任务寄存器:**

​		任务寄存器(TR)是处理器中的一个控制寄存器，用于保存当前正在执行的任务的TSS描述符的段选择器。当任务切换发生时，处理器使用TR来定位当前执行任务的TSS。
​		当任务切换发生时，处理器将新任务的TSS描述符的段选择器加载到TR中，这导致处理器开始从新任务的TSS中执行代码，并将当前任务的状态保存在其TSS中。

**任务门描述符:**

​		任务门描述符是描述任务门的段描述符，任务门是用于调用任务的数据结构。任务门描述符包括要执行的任务的TSS的段选择器和要执行的代码段的选择器。
​		当程序跳转到任务门时，处理器执行任务切换到指定的TSS，并开始执行指定代码段的代码。当前任务的状态保存在其TSS中，新任务的状态从其TSS中加载。任务门用于在操作系统中实现多任务，允许多个任务在单个处理器上并发执行。

#### 3. 任务切换

**任务切换何时发生?**

​		当处理器需要从执行一个任务中的代码切换到执行另一个任务中的代码时，就会发生任务切换。这可能是由于各种原因造成的，例如:

+ 中断:当中断发生时，处理器保存当前任务的状态，并切换到新任务中的中断处理程序代码。

+ 陷阱:陷阱类似于中断，但它们是同步的，并且由特定的指令触发。当发生陷阱时，处理器切换到新任务中的陷阱处理程序代码。

+ 任务门:任务门是GDT或LDT中的一个描述符，它指向特定任务的TSS。当程序执行一条跳转到任务门的指令时，处理器切换到该门所指向的任务。

+ 自愿放弃:任务可以通过执行导致任务切换的指令来自愿放弃对操作系统的控制。

**当任务切换发生时，处理器做什么?**

​		当任务切换发生时，处理器执行以下步骤:

+ 保存当前任务状态:处理器将当前任务的状态保存到当前任务的TSS中，包括通用寄存器、段寄存器和其他控制寄存器的内容。

+ 更新任务寄存器:处理器更新任务寄存器(TR)以指向新任务的TSS。

+ 加载新任务状态:处理器将新任务的状态从TSS加载到适当的寄存器和内存位置。

+ 恢复执行:处理器从任务的指令指针(IP)所指示的指令恢复新任务的执行。

**当中断或异常向量指向IDT表中的中断或陷阱门时，是否会发生任务切换?**

​		会发生，当中断或异常向量指向IDT表中的中断或陷阱门时，就会发生任务切换。当中断或异常发生时，处理器在中断描述符表(IDT)中查找相应的向量，并确定与该向量相关联的门的类型。如果该门是中断门或陷阱门，则处理器在将控制转移到中断或异常处理程序代码之前切换任务。如果门是任务门，则处理器切换任务并开始执行指定任务的代码。另一方面，如果门是调用门或返回门，则不发生任务切换，控制权直接转移到目标代码段。

#### 4. 任务链

**如何判断任务是否嵌套?**

​		通过检查EFLAGS寄存器中的嵌套任务(NT)标志来判断任务是否嵌套。当启用任务嵌套并且发生任务切换时，NT标志被设置为1，表示当前任务嵌套在另一个任务中。

**任务嵌套什么时候发生?**

​		当任务从较低的特权级别切换到较高的特权级别，并且目标TSS设置了Nested Task (NT)标志时，就会发生任务嵌套。这表明新任务本身可以包含嵌套任务。

**当任务嵌套时，哪些标志位被修改?**

​		当任务嵌套时，处理器修改EFLAGS寄存器中的几个标志位，包括嵌套任务(NT)标志、中断使能(IF)标志和恢复标志(RF)位。NT标志设置为1，表示当前任务是嵌套的。将IF标志清除为0，表示当前任务中不允许中断;将RF位设置为1，表示当前任务发生异常后正在恢复执行。

**当任务嵌套时，如何返回到上一个任务?**

​		为了返回到上一个任务，处理器必须执行嵌套任务返回(IRET)指令。该指令恢复前一个任务的状态，包括它的指令指针、堆栈指针和其他寄存器，并清除NT标志，表明当前任务不再嵌套。在IRET指令完成后，处理器在前一个任务被中断的地方恢复执行。

#### 5. 任务地址空间

**什么是任务地址空间?**

​		任务地址空间是在任务执行期间分配给任务的虚拟内存空间。每个任务都有自己的任务地址空间，它为任务提供了一个私有的、隔离的内存空间。

**任务地址空间由什么组成?**

​		任务地址空间由任务可以访问的一系列逻辑地址组成。这些逻辑地址由内存管理单元(MMU)转换为物理地址，物理地址引用存储数据的实际物理内存位置。

**如何将任务映射到线性和物理地址空间?**

​		当一个任务被执行时，它的任务状态段(TSS)包含有关任务内存空间的信息，包括它的代码段、数据段和堆栈段的基址和限制。这些段被映射到线性地址，然后由MMU转换为引用代码、数据和堆栈存储的实际物理内存位置的物理地址。

**了解任务的逻辑地址空间以及如何在任务之间共享数据**

​		每个任务都有自己的逻辑地址空间，逻辑地址空间为任务提供了私有和隔离的内存空间。但是，在任务之间共享数据通常是必要的，例如当多个任务需要访问相同的共享资源时。为此，可以在任务之间分配和共享一个公共内存区域。这可以通过将相同的物理内存映射到每个任务地址空间中的不同逻辑地址来实现，或者通过使用任务间通信机制(如消息传递或共享内存)来实现。操作系统或应用程序必须仔细管理对共享资源的访问，以防止冲突并确保任务之间的正确同步。